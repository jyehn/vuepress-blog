---
title: typescript-for-cp
date: 2022-03-23 20:01:12
permalink: /pages/b6d8bc/
categories:
  - CompetitiveProgramming
tags:
  - 
---
# 刷题用的typescript

记录一下我用typescript刷题的经验
//todo

## 刷题需要的语言特性

### 数据结构

#### 数组
数组翻转
```ts
let reversedA = A.reverse();
//Array.prototype.reverse
```
多维数组的初始化方法
```ts
//初始化mxn的全为0的二维数组
let a = Array(m).fill(0).map(() => {
    new Array(n).fill(0);
})
```
切片方法
```ts
arr.slice(1, 2);//参数为(begin, end), 不包括end
```
#### 队列
循环队列
```ts

```
双端队列
直接用Array来当双段队列似乎复杂度有问题，Array.prototype.shift()和unshift的时间复杂度似乎是O(n)的
#### 栈

#### 优先队列/堆

#### 字符串相关

#### 哈希表和哈希集合
哈希表
```ts
let map = new Map<number, string>(); //创建
map.has(key)                         //查询是否存在key这个键
map.set(key, value)                  //更新(key, value)，如果已有回覆盖
map.delete(key)                      //删除一条记录(key, value)
map.size                             //哈希表的记录数量
map.clear()                          //情况哈希表
map.entries()                        //返回迭代器对象
map.forEach()                        //遍历方法
map.keys()                           //返回key值
```
集合
```ts
let set = new Set<number>();        //创建
set.add(key)                        //添加一个值
set.has(key)                        //查询是否存在
set.delete(key)                     //删除一个值
set.size                            //集合里的记录数量
set.clear()                         //清空
set.entries()                       //返回迭代器对象
set.forEach()                       //便利方法
```

### 算法

### 内置数学函数


#### 二分查找


#### 自定义排序
`Array.prototype.sort()`是原地排序， 默认情况下是将元素转换为字符串比较

```ts
arr = [1, 2, 3,4 5];
arr.sort(function(a, b) { return a - b });
//如果a - b 小于0， 那么a将会排到b前面
```

### 模板

### 排序

```ts
let partition = function(arr: number[], left: number, right: number) {
    let idx: number = Math.floor(Math.random() * (right - left + 1)) + left;
    [arr[idx], arr[left]] = [arr[left], arr[idx]];
    let temp: number = arr[left];
    while (left < right) {
        while (left < right && arr[right] > temp)
            --right;
        arr[left] = arr[right];
        while (left < right && arr[left] <= temp)
            ++left;
        arr[right] = arr[left];
    }
    arr[left] = temp;
    return left;
};
let quickSort = function(arr: number[], left: number, right: number) {
    if (left < right) {
        let pos: number = partition(arr, left, right);
        quickSort(arr, left, pos - 1);
        quickSort(arr, pos + 1, right);
    }
};
```

```ts
 function quickSort(arr: number[], begin: number, end: number) {
        if (begin >= end) return;
        
        let left: number = begin - 1,
            right: number = end + 1,
            temp: number = arr[(left + right) >> 1];
        while (left < right) {
            while (arr[++left] < temp);
            while (arr[--right] > temp);
            if (left < right) [arr[right], arr[left]] = [arr[left], arr[right]];
        }
        quickSort(arr, begin, right);
        quickSort(arr, right + 1, end);
    }
```

### 牛客题库

#### NC78 反转链表

```ts
//递归
export function ReverseList(head: ListNode): ListNode {
    // write code here
    if (head === null || head.next === null) return head;
    let p = ReverseList(head.next);
    head.next.next = head;
    head.next = null;
    return p;
}
```

```ts
//迭代
export function ReverseList(head: ListNode): ListNode {
  // write code here
    if (!head) return null;
    let curr: ListNode = head.next;
    let prev: ListNode = head;
    while (curr !== null) {
        let next: ListNode = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    head.next = null;
    return prev;
}

```

#### NC140 排序

见前文排序算法

#### NC93 设计LRU缓存结构

```ts
class DLinkNode {
    public prev: DLinkNode | null;
    public next: DLinkNode | null;
    public key: number;
    public val: number;
    constructor(key: number, val: number) {
        this.key = key;
        this.val = val;
    }
}
export class Solution {
    size: number = 0;
    capacity: number;
    dummyHead: DLinkNode;
    dummyTail: DLinkNode;
    m: Map<number, DLinkNode> = new Map<number, DLinkNode>();
    constructor(capacity: number) {
        // write code here
        this.capacity = capacity;
        this.dummyHead = new DLinkNode(NaN, NaN);
        this.dummyTail = new DLinkNode(NaN, NaN);
        this.dummyHead.next = this.dummyTail;
        this.dummyTail.prev = this.dummyHead;
    }

    get(key: number): number {
        // write code here
        if (this.m.has(key)) {
            let p = this.m.get(key);
            p.prev.next = p.next;
            p.next.prev = p.prev;
            p.next = this.dummyHead.next;
            this.dummyHead.next.prev = p;
            p.prev = this.dummyHead;
            this.dummyHead.next = p;
            return p.val;
        }else {
            return -1;
        }
    }

    set(key: number, value: number): void {
        // write code here
        if (this.m.has(key)) {
            let p = this.m.get(key);
            p.val = value;
            p.prev.next = p.next;
            p.next.prev = p.prev;
            p.next = this.dummyHead.next;
            this.dummyHead.next.prev = p;
            p.prev = this.dummyHead;
            this.dummyHead.next = p;
        }else {
            let p = new DLinkNode(key, value);
            this.m.set(key, p);
            p.next = this.dummyHead.next;
            this.dummyHead.next.prev = p;
            this.dummyHead.next = p;
            p.prev = this.dummyHead;
            if (this.size === this.capacity) {
                let temp = this.dummyTail.prev;
                let beforeLast = this.dummyTail.prev.prev;
                beforeLast.next = this.dummyTail;
                this.dummyTail.prev = beforeLast;
                this.m.delete(temp.key);
                temp = null;
            }else {
                ++this.size;
            }
        }
    }
}

```

#### NC45 实现二叉树先序，中序和后序遍历
非递归的后面再补
//todo

```ts
const ans: number[][] = new Array(3).fill(0).map(() => new Array());
function preOrder(root: TreeNode): void {
   if (root) {
       ans[0].push(root.val);
       preOrder(root.left);
       preOrder(root.right);
   } 
};
function inOrder(root: TreeNode): void {
    if (root) {
        inOrder(root.left);
        ans[1].push(root.val);
        inOrder(root.right);
    }
};
function postOrder(root: TreeNode): void {
    if (root) {
        postOrder(root.left);
        postOrder(root.right);
        ans[2].push(root.val);
    }
}
export function threeOrders(root: TreeNode): number[][] {
    // write code here
    preOrder(root);
    inOrder(root);
    postOrder(root);
    return ans;
}
```
#### NC119 最小的K个数
```ts
class Heap {
    arr: number[] = [];
    n: number;
    constructor(arr: number[]) {
        this.arr.push(Infinity);
        this.arr.splice(1, 0, ...arr);
        this.n = arr.length;
        this.build();
    }
    build(): void {
        for (let i = ~~(this.n / 2); i >= 1; --i) {
            this.downAdjust(i, this.n);
        }
    }
    //向下调整
    downAdjust(low:number, high: number): void {
        let i = low,
            j = i * 2;
        while (j <= high) {
            if (j + 1 <= high && this.arr[j + 1] < this.arr[j])
                j = j + 1;
            if (this.arr[j] < this.arr[i]) {
                [this.arr[j], this.arr[i]] = [this.arr[i], this.arr[j]];
                i = j;
                j = i * 2;
            }else {
                break;
            }
        }
    }
    //向上调整
    upAdjust(low: number, high: number): void {
        let i = high,
            j = i >> 1;
        while (j >= low) {
            if (this.arr[i] < this.arr[j]) {
                [this.arr[i], this.arr[j]] = [this.arr[j], this.arr[i]];
                i = j;
                j = i >> 1;
            }else {
                break;
            }
        }
    }
    pop(): number {
        let arr = this.arr;
        let res = this.arr[1];
        [arr[1], arr[this.n]] = [arr[this.n], arr[1]];
        --this.n;
        this.downAdjust(1, this.n);
        return res;
    }
    push(x: number) {
        if (this.arr.length < this.n + 1) {
            this.arr.push(x);
            ++this.n;
        }else {
            this.arr[++this.n] = x;
        }
        this.upAdjust(1, this.n);
    }
}
export function GetLeastNumbers_Solution(input: number[], k: number): number[] {
    // write code here
    let heap = new Heap(input);
    let ans: number[] = [];
    k = Math.min(input.length, k);
    while (k--) {
        ans.push(heap.pop());
    }
    return ans;
}
```
#### NC88 寻找第K大
```ts
export function findKth(a: number[], n: number, K: number): number {
    // write code here
    function partition(left: number, right: number): number {
        let randIdx = ~~(Math.random() * (right - left + 1)) + left;
        [a[randIdx], a[left]] = [a[left], a[randIdx]];
        let temp = a[left];
        while (left < right) {
            while (left < right && a[right] <= temp) --right;
            a[left] = a[right];
            while (left < right && a[left] > temp) ++left;
            a[right] = a[left];
        }
        a[left] = temp;
        return left;
    }
    function quickSelect(left: number, right: number): number {
        let pos = partition(left, right);
        if (pos === K - 1) {
            return a[pos];
        }
        else if (pos < K - 1) {
            return quickSelect(pos + 1, right);
        }else {
            return quickSelect(left, pos - 1);
        }
    };
    return quickSelect(0, a.length - 1);
}
```

#### NC15 求二叉树的层序遍历
深度优先搜索（虽然有点怪， 但是这样是正确的）
```ts
export function levelOrder(root: TreeNode): number[][] {
    // write code here
    let ans: number[][] = [];
    function dfs(node: TreeNode, depth: number): void {
        if (node) {
            if (ans.length > depth) {
                ans[depth].push(node.val);
            }else {
                while (ans.length <= depth) {
                    ans.push([]);
                }
                ans[depth].push(node.val);
            }
            dfs(node.left, depth + 1);
            dfs(node.right, depth + 1);
        }
    }
    dfs(root, 0);
    return ans;
}
```
广度优先搜索（灵性用两个数组保存当前层和下一层的结点）
```ts
export function levelOrder(root: TreeNode): number[][] {
    // write code here
    let curr: TreeNode[] = [];
    curr.push(root);
    let ans: number[][] = [];
    while (curr.length > 0) {
        ans.push([]);
        let next: TreeNode[] = [];
        curr.forEach((node) => {
            ans[ans.length - 1].push(node.val);
            if (node.left) next.push(node.left);
            if (node.right) next.push(node.right);
        })
        curr = next;
    }
    return ans;
}
```

#### NC61 两数之和
```ts
export function twoSum(numbers: number[], target: number): number[] {
    // write code here
    let m = new Map<number, number>();
    let ans = [-1, -1];
    numbers.forEach((value, index) => {
        if (m.has(target - value)) {
            ans = [m.get(target - value) + 1, index + 1];
        }
        m.set(value, index);
    })
    return ans;
}
```
#### NC33 合并两个排序的链表
```ts
export function Merge(pHead1: ListNode, pHead2: ListNode): ListNode {
    // write code here
    let dummy = new ListNode();
    let p = dummy;
    while (pHead1 && pHead2) {
        if (pHead1.val < pHead2.val) {
            p.next = pHead1;
            p = p.next;
            pHead1 = pHead1.next;
        }else {
            p.next = pHead2;
            p = p.next;
            pHead2 = pHead2.next;
        }
    }
    if (pHead1) {
        p.next = pHead1;
    }
    if (pHead2) {
        p.next = pHead2;
    }
    return dummy.next;
}
```

#### NC76 用两个栈实现队列

```ts
const stk1: number[] = [];
const stk2: number[] = [];


export function push(node: number) {
    // write code here
    stk1.push(node);
}

export function pop(): number {
    // write code here
    if (stk2.length === 0) {
        while (stk1.length > 0) {
            stk2.push(stk1.pop());
        }
    }
    return stk2.pop();
}
```

#### NC68 跳台阶
```ts
export function jumpFloor(number: number): number {
    // write code here
    let f: number[] = Array(number + 1).fill(0);
    f[0] = 1;
    f[1] = 1;
    for (let i = 2; i <= number; ++i) {
        f[i] = f[i - 1] + f[i - 2];
    }
    return f[number];
}
```

#### NC19 连续子数组的最大和
贪心
```ts
export function FindGreatestSumOfSubArray(array: number[]): number {
    // write code here
    let thisSum = 0,
        maxSum = Math.max(...array);
    array.forEach((value, index) => {
        if (thisSum + value < 0) {
            thisSum = 0;
        }else {
            thisSum += value;
            maxSum = Math.max(maxSum, thisSum);
        }
    })
    return maxSum;
}
```
动态规划
```ts
export function FindGreatestSumOfSubArray(array: number[]): number {
    // write code here
    let f = array.slice(0);
    for (let i = 0; i < f.length; ++i) {
        f[i] = Math.max(0, i - 1 >= 0 ? f[i - 1] : 0) + array[i];
    }
    return Math.max(...f);
}
```

#### NC41 最长无重复子数组
```ts
export function maxLength(arr: number[]): number {
    // write code here
    let seen = new Set<number>();
    let ans = 0;
    for (let i = 0, j = 0; i < arr.length; ++i) {
        if (seen.has(arr[i])) {
            while (j <= i && arr[j] !== arr[i]) {
                seen.delete(arr[j]);
                ++j;
            }
            if (j < i && arr[j] === arr[i]) {
                ++j;
            }
        }
        seen.add(arr[i]);
        //这里两种写法都可以
        //ans = Math.max(ans, seen.size);
        ans = Math.max(ans, i - j + 1);
    }
    return ans;
}

```

#### NC4 判断链表中是否有环
哈希表
```ts
export function hasCycle(head: ListNode): boolean {
    // write code here
    let seen = new Set<ListNode>();
    for (let p = head; p ; p = p.next) {
        if (seen.has(p)) return true;
        seen.add(p);
    }
    return false;
}
```
快慢指针
```ts
export function hasCycle(head: ListNode): boolean {
    // write code here
    let fast = head;
    let slow = head;
    while (true) {
        if (fast === null || fast.next === null) break;
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) return true;
    }
    return false;
    
}
```
#### NC22 合并两个有序的数组
```ts
export function merge(A: number[], m: number, B: number[], n: number) {
  // write code here
  for (let i = m - 1, j = n - 1, k = m + n - 1; i >= 0 || j >= 0; ) {
    if (i >= 0 && j >= 0) {
      if (A[i] > B[j]) {
        A[k--] = A[i--];
      } else {
        A[k--] = B[j--];
      }
    }else {
        if (i >= 0) {
            A[k--] = A[i--];
        }else if (j >= 0) {
            A[k--] = B[j--];
        }
    }
  }
}

```
#### NC3 链表中环的入口结点
```ts
export function EntryNodeOfLoop(pHead: ListNode): ListNode {
    // write code here
    let fast = pHead,
        slow = pHead;
    while (true) {
        if (fast === null || fast.next === null) {
            return null;
        }
        slow = slow.next;
        fast = fast.next.next;
        if (fast === slow) break;
    }
    fast = pHead;
    while (fast !== slow) {
        fast = fast.next;
        slow = slow.next;
    }
    return fast;
}
```
#### NC52 有效括号序列
```ts
export function isValid(s: string): boolean {
    // write code here
    let stk: string[] = [];
    let rightParts = ")]}";
    let map = new Map<string, string>();
    map.set(')', '(');
    map.set(']', '[');
    map.set('}', '{');
    for (let i = 0; i < s.length; ++i) {
        let ch = s[i];
        if (rightParts.indexOf(ch) > -1) {
            if (stk.pop() !== map.get(ch))
                return false;
        }else {
            stk.push(ch);
        }
    }
    return stk.length === 0;
}
```
#### NC53 删除链表的倒数第n个节点
```ts
export function removeNthFromEnd(head: ListNode, n: number): ListNode {
    // write code here
    let len = 0;
    for (let p = head; p ; p = p.next, ++len);
    let dummy = new ListNode();
    dummy.next = head;
    let p = dummy;
    for (let i = 0; i < len - n; p = p.next, ++i);
    p.next = p.next.next;
    return dummy.next;
}
```
快慢指针
```ts
export function removeNthFromEnd(head: ListNode, n: number): ListNode {
    // write code here
    let dummy = new ListNode();
    dummy.next = head;
    let fast = dummy,
        i = 0;
    // [1, 2,3 ,4, ... m]
    // [1, 2,3, 4, ..., n, ... m] fast停在n， 需要走m - n + 1步
    // [1, 2,3 ] slow走了m - n + 1步,slow停在正数的m - n + 1个结点上
    while (i < n) {
        fast = fast.next;
        ++i;
    }
    let prev: ListNode = null;
    let slow: ListNode = dummy;
    while (fast !== null) {
        prev = slow;
        fast = fast.next;
        slow = slow.next;
    }
    prev.next = prev.next.next;
    return dummy.next;
}
```
#### NC1 大数加法

```ts
export function solve(s: string, t: string): string {
    // write code here
    let ans: string[] = [];
    s = s.split('').reverse().join('');
    t = t.split('').reverse().join('');
    for (let i = 0, j = 0, g = 0; i < s.length || j < t.length || g; ++i, ++j) {
        if (i < s.length) g += parseInt(s[i]);
        if (j < t.length) g += parseInt(t[j]);
        ans.push( (g % 10) + '');
        g = ~~(g / 10);
    }
    ans = ans.reverse();
    return ans.join('');
}

```


#### NC136 输出二叉树的右视图
```ts
class TreeNode {
  left: TreeNode | null;
  right: TreeNode | null;
  val: number;
  contructor() {
    this.left = null;
    this.right = null;
    this.val = -1;
  }
}
export function solve(xianxu: number[], zhongxu: number[]): number[] {
  // write code here
  function construct(xl: number, xr: number, zl: number, zr: number): TreeNode {
    if (xl > xr) return null;
    let pos: number;
    for (pos = zl; pos <= zr; ++pos) {
      //从中序中寻找根
      if (zhongxu[pos] === xianxu[xl]) {
        break;
      }
    }
    let node = new TreeNode();
    node.val = xianxu[xl];
    let leftSize = pos - zl; //左子树的数量
    node.left = construct(xl + 1, xl + leftSize, zl, pos - 1);
    node.right = construct(xl + leftSize + 1, xr, pos + 1, zr);
    return node;
  }
  let n = xianxu.length;

  let root = construct(0, n - 1, 0, n - 1);
  let ans: number[] = [];
  function dfs(node: TreeNode, depth: number) {
    if (node) {
      if (ans.length <= depth) {
        while (ans.length <= depth)
            ans.push(-1);
        ans[depth] = node.val;
      }
      dfs(node.right, depth + 1);
      dfs(node.left, depth + 1);
    }
  }
  dfs(root, 0);
  return ans;
}
```
#### NC14 按之字形顺序打印二叉树
BFS
```ts
export function Print(pRoot: TreeNode): number[][] {
    // write code here
    let res: number[][] = []
    function bfs(root: TreeNode) {
        let curr: TreeNode[] = [];
        curr.push(root);
        let depth = 0;
        while (curr.length > 0) {
            let next: TreeNode[] = [];
            res.push([]);
            for (let node of curr.reverse()) {
                res[res.length - 1].push(node.val);
                if (depth % 2 === 0) {
                    if (node.right) next.push(node.right);
                    if (node.left) next.push(node.left);
                }else {
                    if (node.left) next.push(node.left);
                    if (node.right) next.push(node.right);
                }
            }
            res[res.length - 1] = res[res.length - 1].reverse();
            ++depth;
            curr = next;
        }
    }
    if (pRoot)
        bfs(pRoot);
    return res;
}
```
DFS
```ts
export function Print(pRoot: TreeNode): number[][] {
    // write code here
    let res: number[][] = [];
    function dfs(node: TreeNode, depth: number) {
        if (node) {
            while (res.length <= depth) {
                res.push([]);
            }
            res[depth].push(node.val);
            dfs(node.left, depth + 1);
            dfs(node.right, depth + 1);
        }
    }
    dfs(pRoot, 0);
    for (let i = 1; i < res.length; i += 2) {
        res[i] = res[i].reverse();
    }
    return res;
}
```
#### NC127 最长公共子串
```ts
export function LCS(str1: string, str2: string): string {
    // write code here
    const m: number = str1.length,
          n: number = str2.length;
    let f: number[][] = Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    //f[i][j] s[i] == s[j], f[i][j] = f[i - 1][j - 1] + 1;
    for (let i = 1; i <= m; ++i)
        for (let j = 1; j <= n; ++j) {
            if (str1[i - 1] === str2[j - 1]) {
                f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1)
            }
        }
    let maxLen = 0;
    let ans: string;
    for (let i = 1; i <= m; ++i)
        for (let j = 1; j <= n; ++j) {
            if (f[i][j] > maxLen) {
                ans = str1.slice(i - f[i][j], i);
                maxLen = f[i][j];
            }
        }
    return ans;
}
```

#### NC66 两个链表的第一个公共结点

哈希表

```ts
export function FindFirstCommonNode(pHead1: ListNode, pHead2: ListNode): ListNode {
    // write code here
    let seen = new Set<ListNode>();
    for (let p = pHead1; p ; p = p.next) {
        seen.add(p);
    }
    for (let p = pHead2; p ; p = p.next) {
        if (seen.has(p)) {
            return p;
        }
    }
    return null;
}
```
两个指针
```ts
export function FindFirstCommonNode(pHead1: ListNode, pHead2: ListNode): ListNode {
    // write code here
    if (!pHead1 || !pHead2) return null;
    //证明，设两个链表相交部分和
    let pA = pHead1,
        pB = pHead2;
    while (pA !== pB) {
        pA = pA === null ? pHead2 : pA.next;
        pB = pB === null ? pHead1 : pB.next;
    }
    return pA;
}

```

#### NC40 链表相加(二)
这里发现了new的一个问题
```ts
export function addInList(head1: ListNode, head2: ListNode): ListNode {
  // write code here
  function reverseList(head: ListNode): ListNode {
    let dummy = new ListNode(-1, null);
    for (let p = head; p; p = p.next) {
      let node = new ListNode(p.val);//为什么这里不能直接用new ListNode(p.val, dummy.next);
      node.next = dummy.next;
      dummy.next = node;
    }
    return dummy.next;
  }
  let h1 = reverseList(head1),
    h2 = reverseList(head2);
  let dummy = new ListNode();
  for (let p1 = h1, p2 = h2, g = 0; p1 || p2 || g; ) {
    if (p1) {
      g += p1.val;
      p1 = p1.next;
    }
    if (p2) {
      g += p2.val;
      p2 = p2.next;
    }
    let node = new ListNode(g % 10);
    node.next = dummy.next;
    dummy.next = node;
    g = ~~(g / 10);
  }
  return dummy.next;
}
```
#### NC102 在二叉树中找到两个节点的最近公共祖先
使用map存储双亲结点
```ts
export function lowestCommonAncestor(root: TreeNode, o1: number, o2: number): number {
    // write code here
    let parent = new Map<TreeNode, TreeNode>();
    let p1: TreeNode,
        p2: TreeNode;
    function dfs (node: TreeNode, p: TreeNode): void {
        if (node) {
            if (node.val === o1) {
                p1 = node;
            }
            if (node.val === o2) {
                p2 = node;
            }
            parent.set(node, p);
            dfs(node.left, node);
            dfs(node.right, node);
        }
    };
    dfs(root, null);
    let seen = new Set<TreeNode>();
    while (p1 !== null) {
        seen.add(p1);
        p1 = parent.get(p1);
    }
    while (!seen.has(p2)) {
        p2 =  parent.get(p2);
    }
    return p2.val;
}
```
递归寻找

```ts
export function lowestCommonAncestor(root: TreeNode, o1: number, o2: number): number {
    // write code here
    let ans: number;
    function dfs(root: TreeNode): boolean {// 是否需要继续搜寻公共祖先
        if (root) {
            if (root.val === o1 || root.val === o2) {
                if (dfs(root.left) || dfs(root.right)) {
                    ans = root.val;
                    return false;
                }else return true;
            }else {
                let l = dfs(root.left),
                    r = dfs(root.right);
                if (l && r) {
                    ans = root.val;
                    return false;
                }else if (l || r) {
                    return true;
                }else {
                    return false;
                }
            }
        }
        return false;
    }
    dfs(root);
    return ans;
}
```
#### NC103 反转字符串
```ts
export function solve(str: string): string {
    // write code here
    return str.split('').reverse().join('');
}
```
#### NC38 螺旋矩阵
```ts
export function spiralOrder(matrix: number[][]): number[] {
    // write code here
    if (matrix.length === 0) return [];
    const m = matrix.length,
          n = matrix[0].length;
    let vis: boolean[][] = Array(m).fill(false).map(() => new Array(n).fill(false));
    let x = 0,
        y = 0,
        ans: number[] = [];
    while (ans.length < m * n) {
        while (y < n && !vis[x][y]) {
            ans.push(matrix[x][y]);
            vis[x][y] = true;
            ++y;
        }
        if (y === n || vis[x][y]) {
            --y;
            ++x;
        }
        while (x < m && !vis[x][y]) {
            ans.push(matrix[x][y]);
            vis[x][y] = true;
            ++x;
        }
        if (x === m || vis[x][y]) {
            --x;
            --y;
        }
        while (y >= 0 && !vis[x][y]) {
            ans.push(matrix[x][y]);
            vis[x][y] = true;
            --y;
        }
        if (y === -1 || vis[x][y]) {
            ++y;
            --x;
        }
        while (x >= 0 && !vis[x][y]) {
            ans.push(matrix[x][y]);
            vis[x][y] = true;
            --x;
        }
        if (x === -1 || vis[x][y]) {
            ++x;
            ++y;
        }
    }
    return ans;
}
```
```ts
export function spiralOrder(matrix: number[][]): number[] {
    // write code here
    if (matrix.length === 0) return [];
    const m = matrix.length,
          n = matrix[0].length;
    let up = 0,
        down = m - 1,
        left = 0, 
        right = n - 1;
    let ans: number[] = [];
    while (true) {
        for (let c = left; c <= right; ++c) {
            ans.push(matrix[up][c]);
        }
        if (++up > down) break;
        for (let r = up; r <= down; ++r) {
            ans.push(matrix[r][right]);
        }
        if (--right < left) break;
        for (let c = right; c >= left; --c) {
            ans.push(matrix[down][c]);
        }
        if (--down < up) break;
        for (let r = down; r >= up; --r) {
            ans.push(matrix[r][left]);
        }
        if (++left > right) break;
    }
    return ans;
}
```
使用方向向量
```ts
export function spiralOrder(matrix: number[][]): number[] {
    // write code here
    if (matrix.length === 0) return [];
    const m = matrix.length,
          n = matrix[0].length;
    const dir = [[0, 1], [1, 0], [0, -1], [-1, 0]];
    let vis: boolean[][] = Array(m).fill(false).map(() => new Array(n).fill(false));
    let ans: number[] = [];
    for (let cnt = 0, d = 0, x = 0, y = 0; cnt < m * n; ) {
        ans.push(matrix[x][y]);
        vis[x][y] = true;
        ++cnt;
        let [sx, sy] = [x + dir[d][0], y + dir[d][1]];
        if (sx < 0 || sx >= m || sy < 0 || sy >= n || vis[sx][sy]) {
            d = (d + 1) % 4;
            [sx, sy] = [x + dir[d][0], y + dir[d][1]];
        }
        x = sx;
        y = sy;
    }
    return ans;
}
```
#### NC65 斐波那契数列
```ts
export function Fibonacci(n: number): number {
    // write code here
    let f: number[] = Array(n + 1).fill(0);
    f[0] = 0;
    f[1] = 1;
    for (let i = 2; i <= n; ++i)
        f[i] = f[i - 1] + f[i - 2];
    return f[n];
}
```

#### NC17 最长回文子串
DP
```ts
export function getLongestPalindrome(A: string): number {
    // write code here
    const n = A.length;
    let f: number[][] = Array(n).fill(0).map(()=> new Array(n).fill(0));
    for (let i = 0; i < n; ++i) f[i][i] = 1;
    for (let i = 0; i < n - 1; ++i) f[i][i + 1] = A[i] === A[i + 1] ? 1 : 0;
    for (let len = 3; len <= n; ++len)
        for (let l = 0; l + len - 1 < n; ++l) {
            let r = l + len - 1;
            f[l][r] = +(f[l + 1][r - 1] && A[l] === A[r]);
        }
    let ans = 0;
    for (let i = 0; i < n; ++i)
        for (let j = i; j < n; ++j) {
            if (f[i][j] > 0)
                ans = Math.max(ans, j - i + 1);
        }
    return ans;
}
```
中心延展
```ts
export function getLongestPalindrome(A: string): number {
    // write code here
    function getLen(l: number, r: number): number {
        while (l >= 0 && r < A.length && A[l] === A[r]) {
            --l;
            ++r;
        }
        return r - l - 1;
    };
    let ans = 0;
    for (let i = 0; i < A.length; ++i) {
        ans = Math.max(ans, getLen(i, i), getLen(i, i + 1));
    }
    return ans;
}
```
#### NC54 三数之和
```ts
export function threeSum(num: number[]): number[][] {
    // write code here
    num.sort(function(a, b) {
        return a - b;
    });
    //如何去重？
    const n = num.length;
    let ans: number[][] = [];
    for (let i = 0; i < n; ) {
        while (i > 0 && num[i] === num[i - 1]) ++i;
        let j = i + 1, k = n - 1;
        while (j < k) {
            let sum = num[i] + num[j] + num[k];
            if (sum === 0) {
                ans.push([num[i], num[j], num[k]]);
                ++j;
                --k;
                while (j < k && num[j] === num[j - 1]) ++j;
                while (j < k && num[k] === num[k + 1]) --k;
            }else if (sum < 0) {
                ++j;
            }else {
                --k;
            }
        }
        ++i;
    }
    return ans;
}
```

#### NC12 重建二叉树

```ts
export function reConstructBinaryTree(pre: number[], vin: number[]): TreeNode {
    // write code here
    function construct(pl: number, pr: number, vl: number, vr: number): TreeNode {
        if (pl > pr) return null;
        let pos: number;
        for (pos = vl; pos <= vr; ++pos) {
            if (vin[pos] === pre[pl]) {
                break;
            }
        }
        let leftSize = pos - vl;
        let root = new TreeNode();
        root.val = pre[pl];
        root.left = construct(pl + 1, pl + leftSize, vl, pos - 1);
        root.right = construct(pl + leftSize + 1, pr, pos + 1, vr);
        return root;
    };
    let n = pre.length;
    return construct(0, n - 1, 0, n - 1);
}

```

#### NC91 最长上升子序列(三)
```ts
export function LIS(arr: number[]): number[] {
    // write code here
    function upperBound(l: number, r: number, val: number) { //>= x的第一个位置
        while (l < r) {
            let mid = (l + r) >> 1;
            if (f[mid] >= val) {
                r = mid;
            }else {
                l = mid + 1;
            }
        }
        return l;
    }
    let n = arr.length;
    let f: number[] = Array(n + 1).fill(0);
    let p: number[] = Array(n + 1).fill(0)//记录i对应的最长上升子序列的长度
    let len = 1;
    p[0] = 1;
    f[len] = arr[0];
    for (let i = 1; i < n; ++i) {
        if (arr[i] > f[len]) {
            f[++len] = arr[i];
            p[i] = len;
        }else {
            let pos = upperBound(1, len, arr[i]);
            f[pos] = arr[i];
            p[i] = pos;
        }
    }
    let ans: number[] = [];
    for (let i = n - 1; i >= 0; --i) {
        if (p[i] === len) {
            ans[--len] = arr[i];
        }
    }
    return ans;
}
```

#### NC32 求平方根
1 << 31会溢出
```ts
export function sqrt(x: number): number {
    // write code here
    // 满足y * y <= x 最大整数y
    let left = 0,
        right = x;
    while (left < right) {
        let mid = (left + right + 1) >> 1;
        if (mid * mid <= x) {
            left = mid;
        }else {
            right = mid - 1;
        }
    }
    return left;
}
```

#### NC48 在旋转过的有序数组中寻找目标值
```ts
export function search(nums: number[], target: number): number {
    // write code here
    const n = nums.length;
    if (n === 1) {
        if (nums[0] === target) return 0;
        else return -1;
    }
    
    let l = 0,
        r = n - 1;
    while (l <= r) {
        let mid = (l + r) >> 1;
        if (nums[mid] === target) return mid;
        else {
            if (nums[l] <= nums[mid]) {//没有跨越旋转点,左边部分有序
                if (nums[l] <= target && target < nums[mid]) {//target在左边部分中
                    r = mid - 1;
                }else {
                    l = mid + 1;
                }
            }else {//跨越了旋转点，右半部分有序
                if (nums[mid] < target && target <= nums[r]) {//target在右半部分中
                    l = mid + 1;
                }else {
                    r = mid - 1;
                }
            }
        }
    }
    return -1;
}
```
#### NC90 包含min函数的栈
```ts
let stk: number[] = [];
let minStk: number[] = [];
export function push(value: number) {
    stk.push(value);
    if (minStk.length > 0) {
        minStk.push(Math.min(minStk[minStk.length - 1], value));
    }else {
        minStk.push(value);
    }
}

export function pop() {
    minStk.pop();
    return stk.pop();
}


export function top(): number {
    return stk[stk.length - 1];
}


export function min(): number {
    return minStk[minStk.length - 1];
}
```

#### NC7 买卖股票的最好时机(一)
```ts
export function maxProfit(prices: number[]): number {
    let ans = 0,
        minPrice = prices[0];
    for (let i = 1; i < prices.length; ++i) {
        ans = Math.max(prices[i] - minPrice, ans);
        minPrice = Math.min(minPrice, prices[i]);
    }
    return ans;
}
```

#### NC51 合并k个已排序的链表
手写堆

```ts
function less(a: ListNode, b: ListNode): boolean {
    return a.val - b.val < 0;
}
class Heap {
    arr: ListNode[] = [];
    n: number;
    constructor(initial: ListNode[]) {
        this.arr.push(new ListNode());
        this.arr.splice(1, 0, ...initial);
        this.n = initial.length;
        this.build();
    }
    build() {
        for (let i = this.n >> 1; i >= 1; --i) {
            this.downAdjust(i, this.n);
        }
    }
    downAdjust(low: number, high: number) {
        let i = low,
            j = i * 2;
        while (j <= high) {
            if (j + 1 <= high && less(this.arr[j + 1], this.arr[j])) {
                j = j + 1;
            }
            if (less(this.arr[j], this.arr[i])) {
                [this.arr[j], this.arr[i]] = [this.arr[i], this.arr[j]];
                i = j;
                j = i * 2;
            }else {
                break;
            }
        }
    }
    upAdjust(low: number, high: number) {
        let j = high,
            i = high >> 1;
        while (i >= low) {
            if (less(this.arr[j], this.arr[i])) {
                [this.arr[j], this.arr[i]] = [this.arr[i], this.arr[j]];
                j = i;
                i = j >> 1;
            }else {
                break;
            }
        }
    }
    push(node: ListNode) {
        if (this.arr.length < this.n + 1) {
            this.arr.push(node);
            ++this.n;
        }else {
            this.arr[++this.n] = node;            
        }
        this.upAdjust(1, this.n);
    }
    pop(): ListNode {
        let node = this.arr[1];
        [this.arr[1], this.arr[this.n]] = [this.arr[this.n], this.arr[1]];
        this.n--;
        this.downAdjust(1, this.n);
        return node;
    }
}
export function mergeKLists(lists: ListNode[]): ListNode {
    lists = lists.filter(node => node);
    let dummy = new ListNode(),
        curr = dummy,
        heap = new Heap(lists);
    while (heap.n > 0) {
        let node = heap.pop();
        curr.next = node;
        curr = curr.next;
        if (node.next) {
            heap.push(node.next);
        }
    }
    return dummy.next;
}
```
归并

```ts
export function mergeKLists(lists: ListNode[]): ListNode {
    function mergeTwoList(pA: ListNode, pB: ListNode): ListNode {
        let dummy = new ListNode(),
            curr = dummy;
        while (pA && pB) {
            if (pA.val < pB.val) {
                curr.next = pA;
                pA = pA.next;
            }else {
                curr.next = pB;
                pB = pB.next;
            }
            curr = curr.next;
        }
        if (pA) {
            curr.next = pA;
        }
        if (pB) {
            curr.next = pB;
        }
        return dummy.next;
    }
    function merge(l: number, r: number): ListNode {
        if (l === r) return lists[l];
        if (l > r) return null;
        let mid = (l + r) >> 1;
        return mergeTwoList(merge(l, mid), merge(mid + 1, r));
    }
    return merge(0, lists.length - 1);
}
```
#### NC121 字符串的排列
```ts
export function Permutation(str: string): string[] {
    let s: string[] = str.split('');
    const n = s.length;
    s.sort();
    let st: boolean[] = Array(n).fill(false);
    let ans: string[] = [],
        temp: string[] = [];
    function getPermutation(j: number) {
        if (j === n) {
            ans.push(temp.join(''));
            return ;
        }
        for (let i = 0; i < n; ++i) {
            if (st[i]) continue;
            if (i > 0 && !st[i - 1] && s[i] === s[i - 1])
                continue;
            temp.push(s[i]);
            st[i] = true;
            getPermutation(j + 1);
            st[i] = false;
            temp.pop();
        }
    }
    getPermutation(0);
    return ans;
}
```
#### NC128 接雨水问题
```ts

```
