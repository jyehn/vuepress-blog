---
title: 二分查找和三分查找常见问题和写法比较
date: 2022-03-16 08:05:59
permalink: /pages/dae3f5/
categories:
  - pages
  - CompetitiveProgramming
tags:
  - 心得
---
# 二分查找和三分查找常见问题和写法比较

二分查找算是常用的算法了，思想比较简洁，但是在实现上有很多的细节和坑点。这篇文章会先从基本的二分查找相等值开始，再到二分查找满足最大值最小（最小值最大）的值，再到三分查找，总结二分查找中容易出错的几个细节，简要分析其原因，给出常见模版的比较，最后主观的附上自己使用的模版代码。


根据个人在做题时候的惨痛教训，总结了一下，二分实现上主要有以下的几个问题
1. 区间写法，以数组$a[0,1,2...n]$为例,$[0,n)$左闭右开，$[0,n-1]$左闭右闭，$(-1,n)$左开右开。有人问写成全闭不就可以了吗，为什么要把不在数组范围中的下标包含进来呢？这里是通常为了用不在数组范围内的下标对应到查找失败的情况
2. 循环的终止条件，`left+1<right`或者`left<right`，这里写错了会有死循环，超时大部分是这个问题
3. 区间端点的变动 比如`left=mid+1;right=mid-1`或者`left=mid;right=mid-1`等等，这里写错了会导致答案错误之类的


必须要说明的是，这三个不同写法在写代码的时候必须是对应的。
## 先从最简单的二分查找说起
问题1：给出一个严格递增的数组$a[0,2,3...n-1]$，在这个数组中找到值等于$x$的下标

直接给出代码
``` cpp
int binary_search(int x){
    int left=0,right=n-1;//[0,n-1]，左闭右闭
    while(left<=right){
        int mid=(left+right)>>1;//(left+right)/2的位运算优化
        if(a[mid]==x) return mid;//查找成功
        else if(a[mid]<x) left=mid+1;
        else right=mid-1;
    }
    return -1;//查找失败
}

```
针对相等值查找的二分代码通常不会有问题
问题1扩展：如果数组a不是严格递增，存在相等值，求值等于x的第一个数

直接使用上面的代码是不可行的，它查找的下标可能不是第一个等于x的数。将这个问题转化一下，求出第一个大于等于x的数的下标，如果该数等于x，那么，就是结果，如果不等于，那么无解

问题2：给出一个非递减的数组$a[0,2,3...n-1]$（存在相等值），在这个数组中找到值小于等于$x$下标最小的数(lower_bound)





## Update 2021.05.20

二分查找的要求并不是序列是单调的，而是序列存在一个边界，左半边的都满足同一个的条件而右半边的不满足这个条件。

二分查找的返回值，要么是右半边的左端点，要么是左半边的右端点。

可以分成以下情况

check函数设置成要求的那个半区的满足的性质

1. `[      ^][        ]`

   左半边满足，右半边不满足。通常要求左半边的右端点
   
   对应代码
   
   ```cpp
   int bsearch_2(int l, int r)
   {
       while (l < r)
       {
           int mid = l + r + 1 >> 1;
           if (check(mid)) l = mid;
           else r = mid - 1;
       }
       return l;
   }
   ```
   
   
   
2. `[      ][^       ]`

   左半边不满足，右半边满足。通常要求右半边的左端点

   对应代码

   ```cpp
   
   int bsearch_1(int l, int r)
   {
       while (l < r)
       {
           int mid = l + r >> 1;
           if (check(mid)) r = mid;
           else l = mid + 1;
       }
       return l;
   }
   ```



